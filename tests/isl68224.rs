use commands::isl68224::*;
use pmbus::*;

fn mode() -> VOutModeCommandData {
    VOutModeCommandData::from_slice(&[0x40]).unwrap()
}

fn dump_data(
    val: u32,
    width: Bitwidth,
    v: &mut std::vec::Vec<((Bitpos, Bitwidth), &str, std::string::String)>,
) {
    let width = width.0 as usize;
    let nibble = 4;
    let maxwidth = 32;

    if width > maxwidth {
        std::println!("{:?}", v);
        return;
    }

    let indent = (maxwidth - width) + ((maxwidth - width) / nibble);

    std::print!("{:indent$}", "", indent = indent);
    std::print!("0b");

    for v in (0..width).step_by(nibble) {
        std::print!(
            "{:04b}{}",
            (val >> ((width - nibble) - v)) & 0xf,
            if v + nibble < width { "_" } else { "\n" }
        )
    }

    while v.len() > 0 {
        let mut cur = width - 1;

        std::print!("{:indent$}", "", indent = indent);
        std::print!("  ");

        for i in 0..v.len() {
            while cur > v[i].0 .0 .0 as usize {
                if cur % nibble == 0 {
                    std::print!(" ");
                }

                std::print!(" ");
                cur -= 1;
            }

            if i < v.len() - 1 {
                std::print!("|");

                if cur % nibble == 0 {
                    std::print!(" ");
                }

                cur -= 1;
            } else {
                std::print!("+--");

                while cur > 0 {
                    std::print!("-");

                    if cur % nibble == 0 {
                        std::print!("-");
                    }

                    cur -= 1;
                }

                std::println!(" {} = {}", v[i].1, v[i].2);
            }
        }

        v.pop();
    }
}

fn dump(data: &impl CommandData) {
    let (val, width) = data.raw();
    let mut v = std::vec![];

    data.interpret(mode, |field, value| {
        v.push((field.bits(), field.desc(), std::format!("{}", value)));
    })
    .unwrap();

    dump_data(val, width, &mut v);
}

macro_rules! bb_field {
    ($slice:expr, $cmd:tt, $word:expr, $offs:expr) => {
        $cmd::CommandData::from_slice(&$slice[($word * 4) + $offs..]).unwrap()
    };
}

struct RenesasBlackboxRail {
    uptime: UptimeCounter::CommandData,
    first_fault: RailFault::CommandData,
    status: STATUS_WORD::CommandData,
    vout_status: STATUS_VOUT::CommandData,
    iout_status: STATUS_IOUT::CommandData,
    temp_status: STATUS_TEMPERATURE::CommandData,
    input_status: STATUS_INPUT::CommandData,
    vin: READ_VIN::CommandData,
    vout: READ_VOUT::CommandData,
    iin: READ_IIN::CommandData,
    iout: READ_IOUT::CommandData,
}

enum RailIndex {
    Rail0,
    Rail1,
    Rail2,
}

impl RenesasBlackboxRail {
    fn from_slice(buf: &[u8], rail: RailIndex) -> Self {
        match rail {
            RailIndex::Rail0 => RenesasBlackboxRail {
                uptime: bb_field!(buf, UptimeCounter, 1, 0),
                first_fault: bb_field!(buf, RailFault, 5, 0),
                status: bb_field!(buf, STATUS_WORD, 11, 0),
                vout_status: bb_field!(buf, STATUS_VOUT, 13, 1),
                iout_status: bb_field!(buf, STATUS_IOUT, 14, 2),
                temp_status: bb_field!(buf, STATUS_TEMPERATURE, 15, 3),
                input_status: bb_field!(buf, STATUS_INPUT, 15, 3),
                vin: bb_field!(buf, READ_VIN, 16, 0),
                vout: bb_field!(buf, READ_VOUT, 18, 2),
                iin: bb_field!(buf, READ_IIN, 19, 0),
                iout: bb_field!(buf, READ_IOUT, 21, 2),
            },
            RailIndex::Rail1 => RenesasBlackboxRail {
                uptime: bb_field!(buf, UptimeCounter, 2, 0),
                first_fault: bb_field!(buf, RailFault, 6, 0),
                status: bb_field!(buf, STATUS_WORD, 12, 2),
                vout_status: bb_field!(buf, STATUS_VOUT, 13, 0),
                iout_status: bb_field!(buf, STATUS_IOUT, 14, 1),
                temp_status: bb_field!(buf, STATUS_TEMPERATURE, 15, 2),
                input_status: bb_field!(buf, STATUS_INPUT, 16, 3),
                vin: bb_field!(buf, READ_VIN, 17, 2),
                vout: bb_field!(buf, READ_VOUT, 18, 0),
                iin: bb_field!(buf, READ_IIN, 20, 2),
                iout: bb_field!(buf, READ_IOUT, 21, 0),
            },
            RailIndex::Rail2 => RenesasBlackboxRail {
                uptime: bb_field!(buf, UptimeCounter, 3, 0),
                first_fault: bb_field!(buf, RailFault, 7, 0),
                status: bb_field!(buf, STATUS_WORD, 12, 0),
                vout_status: bb_field!(buf, STATUS_VOUT, 14, 3),
                iout_status: bb_field!(buf, STATUS_IOUT, 14, 0),
                temp_status: bb_field!(buf, STATUS_TEMPERATURE, 15, 1),
                input_status: bb_field!(buf, STATUS_INPUT, 16, 2),
                vin: bb_field!(buf, READ_VIN, 17, 0),
                vout: bb_field!(buf, READ_VOUT, 19, 2),
                iin: bb_field!(buf, READ_IIN, 20, 0),
                iout: bb_field!(buf, READ_IOUT, 22, 2),
            },
        }
    }
}

struct RenesasBlackbox {
    controller_first_fault: ControllerFault::CommandData,
    cml_status: STATUS_CML::CommandData,
    mfr_specific: STATUS_MFR_SPECIFIC::CommandData,
    rails: [RenesasBlackboxRail; 3],
}

impl RenesasBlackbox {
    fn from_slice(buf: &[u8]) -> Self {
        Self {
            controller_first_fault: bb_field!(buf, ControllerFault, 4, 0),
            cml_status: bb_field!(buf, STATUS_CML, 13, 3),
            mfr_specific: bb_field!(buf, STATUS_MFR_SPECIFIC, 13, 2),
            rails: [
                RenesasBlackboxRail::from_slice(buf, RailIndex::Rail0),
                RenesasBlackboxRail::from_slice(buf, RailIndex::Rail1),
                RenesasBlackboxRail::from_slice(buf, RailIndex::Rail2),
            ],
        }
    }

    fn dump(&self) {
        println!("=== Controller wide");
        dump(&self.controller_first_fault);
        dump(&self.cml_status);
        dump(&self.mfr_specific);

        for (index, rail) in self.rails.iter().enumerate() {
            println!("--- Rail {}", index);
            dump(&rail.uptime);
            dump(&rail.first_fault);
            dump(&rail.status);
            dump(&rail.vout_status);
            dump(&rail.iout_status);
            dump(&rail.temp_status);
            dump(&rail.input_status);
            dump(&rail.vin);
            dump(&rail.vout);
            dump(&rail.iin);
            dump(&rail.iout);
        }
    }
}

#[test]
fn blackbox_test4() {
    let raw = [
        0x00, 0x00, 0x00, 0x00, 0x83, 0x48, 0x01, 0x00, 0x33, 0x4c, 0x01, 0x00,
        0x33, 0x4c, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x58, 0x00, 0x00,
        0x03, 0x10, 0x03, 0x10, 0x00, 0x00, 0x08, 0xa2, 0x00, 0x00, 0x80, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xab, 0x04, 0x00, 0x00, 0xab, 0x04, 0xab, 0x04,
        0xe7, 0x03, 0x84, 0x03, 0x04, 0x00, 0xb0, 0x04, 0x02, 0x00, 0x03, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x0e, 0x0e, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x0f,
        0x00, 0x00, 0x00, 0x00, 0xe9, 0x01, 0xac, 0x04, 0x0f, 0x00, 0x00, 0x00,
        0x0e, 0x0e, 0x0e, 0x0e, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x42, 0xff, 0x80,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    let bb = RenesasBlackbox::from_slice(&raw);
    bb.dump();
}

#[test]
fn blackbox_test7() {
    let raw = [
        0x00, 0x00, 0x00, 0x00, 0x0c, 0x05, 0x00, 0x00, 0x93, 0x0a, 0x00, 0x00,
        0x93, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x58, 0x00, 0x00,
        0x01, 0x10, 0x01, 0x10, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x80, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xab, 0x04, 0x00, 0x00, 0xaa, 0x04, 0xaa, 0x04,
        0xe8, 0x03, 0x84, 0x03, 0x04, 0x00, 0xaf, 0x04, 0x02, 0x00, 0x03, 0x00,
        0x02, 0x00, 0x02, 0x00, 0x0e, 0x0e, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x0f,
        0x00, 0x00, 0x00, 0x00, 0xe9, 0x01, 0xae, 0x04, 0x0f, 0x00, 0x00, 0x00,
        0x0e, 0x0e, 0x0e, 0x0e, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0xaa, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    let bb = RenesasBlackbox::from_slice(&raw);
    bb.dump();
}

#[test]
fn blackbox_test8() {
    let raw = [
        0x00, 0x00, 0x00, 0x00, 0x0c, 0x05, 0x00, 0x00, 0x2f, 0x1f, 0x00, 0x00,
        0x2f, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x58, 0x00, 0x00,
        0x01, 0x10, 0x01, 0x10, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x80, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xab, 0x04, 0x00, 0x00, 0xaa, 0x04, 0xaa, 0x04,
        0xe8, 0x03, 0x84, 0x03, 0x04, 0x00, 0xaf, 0x04, 0x02, 0x00, 0x03, 0x00,
        0x02, 0x00, 0x02, 0x00, 0x0e, 0x0e, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x0f,
        0x00, 0x00, 0x00, 0x00, 0xe9, 0x01, 0xae, 0x04, 0x0f, 0x00, 0x00, 0x00,
        0x0e, 0x0e, 0x0e, 0x0e, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0xaa, 0xff, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];

    let bb = RenesasBlackbox::from_slice(&raw);

    bb.dump();
    println!("{:?}", bb.rails[0].vin.get().unwrap());
    assert_eq!(bb.rails[0].vin.get(), Ok(units::Volts(11.950001)));
}
